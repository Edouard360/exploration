# -*- coding: utf-8 -*-
"""
Created on Wed Apr 19 12:31:45 2017

@author: edouardm
"""
import numpy as np

def sliding_variance(y, w_length):
    """
    :param y: The series on which to perform the variance and autocovariance analysis
    :param w_length: The length of the window
    :return: An series of the same lenght than y (with nan values at the beginning)
    """
    sample_size = len(y)
    sliding_variance = [np.var(y[i:i + w_length]) for i in range(sample_size - w_length + 1)]
    return np.concatenate((np.repeat(np.nan, w_length - 1), np.array(sliding_variance)))

def autocovariance(y_t1, y_t2, autocorrelation=False):
    assert y_t1.size == y_t2.size
    cov = (1 / y_t1.size) * (np.correlate(y_t1, y_t2)[0]) - np.mean(y_t1) * np.mean(y_t2)
    if autocorrelation == True:
        cov = cov / np.var(y_t1)  # var(y_t1) varies...
        # Maybe it has only meaning for the ARIMA process
    return cov

def sliding_autocovariance(y, w_length, lag):
    sample_size = len(y)
    sliding_autocovariance = [autocovariance(y[i:i + w_length], y[i + lag:i + w_length + lag]) for i in
                              range(sample_size - (w_length + lag) + 1)]
    return np.concatenate((np.repeat(np.nan, w_length + lag - 1), np.array(sliding_autocovariance)))
